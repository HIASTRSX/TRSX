#  铁人三项文档

## 操作系统部分

### 1.实验目的

1. 设计一个操作系统引导程序(start.S)。模拟CPU上电后，从默认地址执行Boot Loader代码，拷贝内核程序到内存，并跳转到内核程序中执行的过程。

2. 编写操作系统内核程序(kernel.c)。

   完成打印设备、时间片、线程控制块TCB以及中断控制器PLIC等的初始化。

   实现线程的非抢占式调度，主动交出控制权，实现时间片轮转调度。

   实现线程的抢占式调度，通过外部中断触发被动交出控制权，同时实现中断处理。

3. 设计实现QEMU仿真模拟器和FPGA实验板的统一透明化处理，便于线程调度和管理。

### 2.操作系统设计方案

#### 2.1 系统架构设计

​	图2.1展示了整个操作系统的架构。首先最底层的CPU部分不是操作系统的内容，之所以我把其罗列进来是因为在物理开发板进行测试的周期长、难度大，在实际开发过程中需要一个虚拟的物理开发板作为初步的单元测试以及集成测试。所以我们可以从图中的CPU层中发现两套模块：FPGA与QEMU。FPGA为课程发放的赛灵思开发板，QEMU为操作系统初步测试的虚拟开发板

![image-20231206144253897](/home/wxt/.config/Typora/typora-user-images/image-20231206144253897.png)

<center>图2.1 操作系统架构设计图</center>

​	为了使操作系统Kernel可以在两个开发板之间无差别切换，需要在Kernel层与CPU中间加入若干层进行屏蔽，这便是BootLoader与Board的作用。BootLoader层主要包含操作系统的引导程序，而Board层主要包含与底层物理环境相关的代码，如串口驱动以及定时器驱动。这两层的工作内容随着底层工作环境的变化而变化，进而达到为Kernel屏蔽两套物理环境差异的作用。

​	最后是我们的Kernel层，这也是操作系统的核心部分。在这一部分中主要包括系统部分与应用部分。其中的系统部分主要包括对于线程和中断的管理，并在此之上运行课程说明的三个应用程序以及三个用户线程。

#### 2.2 中断管理设计说明

​	在RISC-V体系架构中，可以通过为mtevc寄存器赋值的方式设置中断处理函数，并且根据mtevc的低2位设置两种模型：Direct模式和Vectored模式。由于本系统实现中断的数量较少，所以采用简单的Direct模式

​	整个中断响应过程如图2.2所示。

![image-20231206144619027](/home/wxt/.config/Typora/typora-user-images/image-20231206144619027.png)

<center>图2.2 中断处理流程图</center>

​	需要说明的是此处中断处理开始以及结束之前需要保存和恢复发生中断时的线程的上下文。而在之后的线程切换过程中，也需要执行保存和恢复线程上下文的操作，二者保存上下文的空间在本系统中均设置在线程的TCB中，但是不可以保存在同样的位置，否则一旦线程切换是由中断发起就会产生严重的错误。

​	在与负责CPU设计的同学们协商过后，本系统中主要实现的四个中断，分别时一个计时器中断（用于实现之后的时间片线程调度）以及三个按键控制中断（用于实现抢占式线程调度）。

#### 2.3 线程管理设计说明

​	小组成员在考虑课程设计要求之后，决定设计两种线程切换方式：基于时间片的线程切换，以及基于按键中断的抢占式线程切换，并分别实现一个计时器中断处理程序和3个按键中断处理程序。同时为了加快线程切换的速度，本系统设计的各种队列（如就绪队列）均采用双向链表数据结构进行实现。

##### 2.3.1时间片线程切换

​	根据业内分时操作系统的主流概念，本系统首先设计基于时间片切换的线程管理模式，本质上属于FIFO的线程切换方式。具体切换流程如图2.3所示：当来自计时器的信号发起中断时，相应的中断处理程序会将当前占用CPU的线程控制块至于就绪队列的队尾，并保存该线程的上下文环境。之后恢复就绪队列对头TCB的各种寄存器环境，实现切换线程的目的。

![image-20231206144946777](/home/wxt/.config/Typora/typora-user-images/image-20231206144946777.png)

<center>图2.3 时间片线程切换示意图</center>

##### 2.3.2抢占式线程切换

为了提高对于执行紧急任务的线程的响应性，本系统同样设计了基于按键中断的抢占式线程切换功能。具体实现流程如图2.4所示。根据赛灵思开发板的按键，CPU设计小组将其绑定到对应的中断信号处。待收到对应的中断信号后，中断处理程序会将当前占用CPU的线程置于就绪队列的队尾，之后将该中断信号关联的TCB从就绪队列中移除并占用CPU。通过这种方式实现实时抢占式切换线程的功能。

![img](file:////tmp/wps-wxt/ksohtml/wpsgO1EFL.jpg)

<center>图2.4 抢占式线程切换示意图

#### 2.4 Bootloader设计说明

​	Bootloader程序根据处理器设计同学设计的架构编写而成。主要目的就是将SD卡中固定扇区保存的操作系统程序及手写数字识别程序所需要的权重数据及图像数据搬移到事先约定好的内存地址处。保证操作系统程序可以正常、正确运行。Bootloader程序处理流程如下图所示：

![image-20231206145212806](/home/wxt/.config/Typora/typora-user-images/image-20231206145212806.png)

<center>图2.5 bootloader程序处理流程图

​	Bootloader在处理器上电之后就会立即执行。首先初始化中断处理程序，这里的中断处理程序主要是关于读写SD相关，其他中断处理程序将会在OS程序执行内部进行初始化。随后bootloader会将OS前两个扇区搬移进DTCM中，之后根据elf头部信息计算OS程序的大小，随之计算总共扇区数目。随后根据大小选择搬移进入ITCM还是SRAM中。若搬进SRAM中则还需要搬移手写数字识别需要的图像及权重数据。最后跳转进OS程序执行入口开始执行。

#### 2.5 手写数字识别编写说明

​	在实现手写数字识别功能中，使用卷积神经网络进行实现。为了加快运行速度，成员对AlexNet网络进行大幅度剪枝，网络本身只有卷积、池化、全连接三个网络层，并使用Relu激活函数。使用Minist数据集进行训练，将续训练后的权重数据保存至本地中（主要是卷积层权重及全连接层权重数据），并在文件头部自定义相关说明与魔数。

​	移植过程中需要用C代码重新实现网络的各种运行，相关代码位于cnn_utils.c文件中。推理程序首先从预定义的图像内存地址处读取（这里为0x20000000）图像数据文件头，并根据图像数量及大小加载所有图像数据。同理在预定义地址处（这里为0x20002000）读取权重数据头，并根据头部信息加载卷积层权重数据及全连接层权重数据。

​	在推理过程中通过串口打印原始图像信息及神经网络判定的各种结果的概率值，效果如下图所示：

![image-20231206145343633](/home/wxt/.config/Typora/typora-user-images/image-20231206145343633.png)

<center>图2.6 手写数字识别FPGA运行串口输出图

### 3.仿真结果及分析

​	本章节主要介绍操作系统部分在QEMU模拟开发板上进行仿真的结果，并对其进行分析。通过小组内设计的编译器对三个用户程序编译成object文件，并使用开源risc-v交叉编译器对其余代码进行编译，最终将所有object文件链接为risc-v架构的可执行文件。仿真结果如下所示：

![image-20231206145514192](/home/wxt/.config/Typora/typora-user-images/image-20231206145514192.png)

<center>图3.1 仿真结果1
    
</center>

![image-20231206145547882](/home/wxt/.config/Typora/typora-user-images/image-20231206145547882.png)

<center>图3.2 仿真结果2</center>

​	上图展示了操作系统程序在QEMU模拟器中进行仿真的实现效果。如图所示操作系统在启动过程中首先按照要求start.S函数中打印“It’s bootblock!”，紧接着kernel中打印“Hello,OS!”字符串，并运行三个功能的应用程序：最短路径、快速排序、最大公约数。

​	紧接着系统按照时间片线程切换模式交替执行主线程以及三个用户线程，具体执行的效果如上图所示。

​	最后开始测试抢占式切换线程功能，本系统中一共分配了三个按键，1号按键对应print_task线程，2号按键对应count_task线程，3号按键对应draw_task线程。具体执行的效果如图3.3所示。

![image-20231206145652028](/home/wxt/.config/Typora/typora-user-images/image-20231206145652028.png)

<center>图3.3 仿真结果3</center>

​	根据图3.3结果，按动对应的按键确实达到了切换对应线程的目的，并且重复切换2号线程也会增加其记录调用次数的标志位。

SourceURL:file:///media/wxt/Ventoy/实验报告wangzhe.docx

## **4.实验收获**

​	在这次课程设计大作业中，通过视频课的基础自学和练习、组员们相互沟通协作以及反复DEBUG的测试，对RISC-V操作系统部分进行了初步实现，并在QEMU上进行了仿真，且在FPGA实验板上运行，对RISC-V操作系统部分有了比书本层面更深层次的理解和感悟，是一次将知识付诸实践并可视化的过程，对于计算机体系结构的认知不再停留在表面知识，而是真正可以运用出来，是一次深刻而收获颇多的实验体验。

​	对于操作系统部分，一个印象较深的是对于QEMU和FPGA的透明化设计，在组员共同协商下，因为一方面要使后续应用程序能在QEMU仿真模拟器上正常调度运行，另一方面要使FPGA实验板能正常调度和实现，所以正如计算机网络层次的透明化处理一样，设计了一层透明层board，可以屏蔽两者的区别，而使高层线程可以便于调度和管理，是较为巧妙的小设计。另外一个印象较深的部分是线程切换部分(位于os.S)，由于若线程切换采用C语言编写，则对于切换过程保存现场和恢复现场信息部分的C代码会相当繁琐且耗时极长。由于支持汇编代码，且RISC-V中断处理部分可以采用专门的寄存器保存信息，可以高效快速保存线程切换前后现场信息，另外ret语句非常巧妙，此语句是为返回到ra寄存器所指向的位置，而ra可以定位线程处理函数，并可指向下一线程，实现线程a和b的切换。若在此次线程切换前，下一个将要切换的线程b已在CPU中，则从上次被打断的地方继续执行，若未在CPU中，则从头开始执行下一个线程，若采用其他语句，无此巧妙效果。此外，对于线程切换部分，实现了两种调度方式，一是时间片轮转方式，以链表方式存储就绪队列，设定时间片大小，把当前已执行完线程重新放入队列尾部，实现线程调度。二是按键触发外部中断，进而让线程被动交出控制权，切换回来后可接着上次切换点继续执行。





