#  铁人三项文档

## SoC设计部分

## 1.实验目的

设计一款RISC-V架构处理器，支持I、M指令集，支持中断操作。能够运行编写的操作系统软件。

## 2.设计方案



## 2.1 RISC-V处理器设计

​	RISC-V架构的模块化指令子集包括基本整数指令集I、整数乘法和除法指令集M、浮点指令集F和D、存储器原子操作指令集A、压缩指令集C等。其中最基本、必须要求实现的指令集部分是基本整数指令集I，使用该指令子集便能够实现完整的软件编译。我们设计的处理器为32位三级流水架构：取指、译码、执行（写回）。顺序执行顺序写回，实现了I、M指令集，支持按键、定时等中断触发信号，如图1.1所示。

<img src="/home/wxt/.config/Typora/typora-user-images/image-20231206153830704.png" alt="image-20231206153830704" style="zoom:150%;" />

<center>图1.1 处理器架构

### 2.1.1 IF取指

​	取指模块IF功能为计算下一次指令取指地址值PC，将PC值通过IBUS接口传给指令存储器，指令存储器读出指令字传给第二级的译码模块ID。PC地址值的计算分为两种情形。第一种是如果上一条指令不是跳转指令，则下次PC地址值的计算为递增4（地址以字节为单位，指令长度为32 bits，故每条指令占4个字节）。第二种上一条指令为跳转指令，则跳转到的目的地址原来的PC地址值不再是递增4的关系。需要根据跳转指令具体内容重新计算PC地址值。指令存储器根据取指模块IF提供的PC地址值，经过一级寄存器IF/ID，在下一时钟周期将对应的指令字传给译码模块ID。

### 2.1.2 ID译码

​	译码模块ID对上一级传来的32 bits指令字进行译码操作，包括控制信号译码、指令类型译码、读寄存器等等。控制信号为Regwrite、MemRead、MemWrite。

Regwrite：表示该条指令需要写回目的寄存器。

MemRead：表示该条指令需要对存储器进行读操作，即load指令。

MemWrite：表示该条指令需要对存储器进行写操作，即store指令。

​	指令类型译码则得到该指令的类型，不同的指令类型运算不同，包括ALU运算指令alu_info_bus、分支跳转指令bjp_info_bus、存储器访问指令mem_info_bus、乘除法指令muldiv_info_bus等。如果译码得到的是分支跳转指令，则还需要将该指令对应的译码信息传递给分支预测模块ID_Branch，进行分支指令下一条指令PC地址值的预测计算，及时回传给取指模块IF，避免流水线停顿降低执行效率。

​	译码模块准备该指令后面运算所需要的操作数。将寄存器编号传递给寄存器堆RF（RegFile），从寄存器堆读出的源操作数数据再通过ID/EX寄存器传递给后面执行模块EX，进行运算。目的寄存器编号配合控制信号Regwrite或MemRead在写回阶段用来将写回寄存器编号和写使能信号回传给寄存器RF，进行写回操作。立即数直接生成传递给ID/EX寄存器，传给EX执行模块。

### 2.1.3 EX执行

​	执行模块EX根据不同的指令类型进行不同的运算操作。ALU运算指令alu_info_bus操作包括加法、减法、逻辑左移、逻辑右移、算术右移、异或、位或、位于等操作。分支跳转指令bjp_info_bus操作类型为比较。存储器访问指令mem_info_bus操作类型为加法，计算要访问的存储器地址。乘除法指令muldiv_info_bus操作类型为乘法和除法。不同的类型指令有着各自对于的运算操作，如果按照每种类型指令进行相应地操作，则不可避免会增加硬件资源消耗。譬如，ALU运算指令中包含加法操作，存储器访问指令也需要加法操作，分别对两种指令进行执行操作，则需要用到多个加法器。为了节省资源面积，降低功耗，在EX执行阶段对指令操作重新进行规划分类，使得同一种操作的指令，根据选择器选择不同指令的操作数，均使用同一个运算模块来完成。例如对于加法运算，对应所有需要进行加法操作的指令，包括add、addi、sub、auipc、load、store、jal、jalr指令。信号add_op1、add_op2、add_cin分别表示根据不同是指令信号选取的相应的操作数。最终加法结果add_result在add_en信号有效时，计算对应的操作数加法。在add_en信号无效时，保持为0，不执行加法操作，这样在处理器进行其他操作时关闭加法器，以尽可能降低功耗。整个执行模块的指令运算，仅有一个加法器（除法器中的加法器不复用，因为除法操作为多周期指令）。

​	访存也是EX执行模块的一部分，根据load/store指令对存储器进行读写控制。其地址由EX执行模块加法运算得到，存储器使能控制信号由译码模块ID得到的控制信号(MemRead | MemWrite)决定，写控制信号则为MemWrite，通过DBUS数据接口将这些控制信号传递给数据存储单元。对于读存储器load指令，直接在将读出来的数据在写回模块写回目的寄存器。对于写存储器store指令，还需要准备写入存储器的数据。根据不同的写指令类型以及不同地址位低两比特偏移，准备对应的写入存储器的数据。

​	在执行完成后，立即进行写回操作，将前面的运算结果数据写回对应的目的寄存器。该数据有两种情况，一种是EX执行模块计算完成需要写回的数据，另一种是读存储器load指令从存储器模块读出的数据。EX执行模块的计算结果在EX执行阶段完成时直接写入寄存器，以节省时钟周期数，减少可能的指令相关，其写回控制信号为ID译码模块的控制信号Regwrite。load指令从存储器中读出数据后立即写入寄存器，比执行模块写入寄存器多一个时钟周期，其写回控制信号为MemRead。

### 2.1.4 数据冲突的冒险处理

​	由于采用顺序执行、顺序写回的架构，所以只存在先写后读（RAW）冒险，并采用运算结果旁路前递的解决方案，以减少流水线停顿，提高指令吞吐率。一般运算指令，如加法运算、逻辑运算等等，执行与写回在同一个周期，指令在流水线中只存在三个时钟周期，所以这些指令之间的数据冲突不会导致流水线停顿。但对于长周期执行指令，如访存指令、除法指令等，则需要流水线停顿以等待运算结果完成。图1.2表示载入——使用型数据冒险，即一条Load加载指令写入某个寄存器，紧跟着它下一条指令就要使用这个寄存器当做源操作数。图2.7说明了该问题。在第4个时钟周期时，数据还正在存储器中被读取，但此时ALU已经在执行下一条指令操作了。当加载指令后跟着一条需要读取加载指令结果的指令时，流水线必须被阻塞以消除这种指令组合带来的冒险。

![image-20231206154209516](/home/wxt/.config/Typora/typora-user-images/image-20231206154209516.png)

<center>图1.2 载入——使用型数据冒险指令序列</center>

## 2.2 **SoC设计**

### 2.2.1 哈佛架构SoC

​	图2.1为本课题设计的整体SoC架构。RISC-V处理器挂载在AHB总线上master端，ITCM、DTCM、UART/TIMER挂载在AHB总线的slave端。处理器通过IBUS总线接口只能访问ITCM外设，负责取指；DBUS总线接口可以访问所有外设：1）在启动函数中将数据段从ITCM中搬移到DTCM中；2）通过load/store指令访问数据段存储区间DTCM；3）通过load/store指令控制外设，实现串口打印、配置定时器进行计时。

![image-20231206154420802](/home/wxt/.config/Typora/typora-user-images/image-20231206154420802.png)

<center>图2.1 哈佛架构SoC设计

### 2.2.2 增添ROM存放引导程序

​	该版本主要是加入boot程序，用于上电后将系统代码从SD卡载入片上存储空间。为此扩展了AHB总线架构，如下图2.2所示，从端增加了ROM、SDRAM、SD卡模块。其中ROM大小为16kB，用于存放boot程序。SDRAM最大为256MB，为片外存储空间，如果程序大小超过ITCM（64kB），或是有大量图像数据等等，存放在SDRAM中，这样无论取指还是访问数据，IBUS和DBUS都是访问SDRAM区间，每次访存都需要暂停取指，会导致流水线执行效率低。SD卡为二进制文件初始时存入的外设，这里依旧使用ram模块来模拟，方便modelsim仿真。并且中间增加了AHB转APB桥，实际过程中SD卡读取频率要比处理器运行频率慢很多，故使用APB总线接口，更低的时钟频率驱动SD模块。AHB转APB桥实现跨异步时钟数据处理。

​	上电后处理器从boot程序执行：boot程序通过load、store指令先将SD卡中文件头数据，即第0块的数据512 Bytes搬移到ITCM中（boot程序默认程序代码从SD卡第0块地址开始存放），计算出整个程序文件大小。如果程序文件大小不超过64kB，则计算出剩余文件量在SD卡中占据了多少块，通过load、store指令全部搬入ITCM中；否则搬入SDRAM中。然后再跳转到ITCM或是SDRAM的程序执行入口start处，开始进入程序代码继续后续执行。

![image-20231206154518363](/home/wxt/.config/Typora/typora-user-images/image-20231206154518363.png)

<center>图2.2 增添ROM扩展SoC设计

### 2.2.3 增添DMA控制SD卡读取

​	该版本加入了完整的DMA、SD卡读取控制模块、异步fifo等，将SD卡中数据搬移到相应地址区间（ITCM、DTCM、SDRAM），如下图2.3所示

SD卡数据读取流程：

​	1）上电后，处理器执行ROM中固定地址boot程序：初始化中断信号（打开中断使能、清除mcause等），通过外设地址写入DMA控制寄存器，包括读取SD卡起始扇区地址SDStartAddr（地址：0x4000_0020），读取SD卡连续的块数SDCounts（0x4000_0024），写入的AHB存储区间地址DestAddr，开始读取SD卡使能信号DMAEN。当写入完成DMAEN寄存器时，DMA开始读取SD卡数据。

​	2）DMA检测到DMAEN寄存器被配置后，向SD卡读取控制模块SD_CTRL发送信号，即SDStartAddr、SDCounts、DMAEN内容。SD_CTRL检测到DMAEN信号后，开始从SDStartAddr块（SD卡每块大小为512 bytes）地址处开始读取SD卡数据，SD卡每次读出一个完整数据32 bits，都会存入异步fifo（由于SD读取数据时钟频率要比处理器运行频率低得多，需要通用异步fifo完成数据的跨时钟域传输）。每存入异步fifo一个数据，DMA模块检测异步fifo非空时，在总线准备好（dma_hready）的状态下都会读取异步fifo中数据，写入DestAddr地址处，每次写完地址递增4，等待下次写入。

​	3）直至读取完成所有SDCounts块数的数据，DMA触发搬移SD数据完成信号，传给处理器核。处理器检测到后触发SD卡数据搬移完成中断（在SD卡数据搬移期间，处理器核一直在检测相关搬移完成标志位，在空转），进入相应中断例程程序。开始下一步相关程序执行。

​	当SD卡中所有数据搬移完成后，PC寄存器跳转到相应的地址区间（ITCM或者SDRAM）开始执行主程序。

![image-20231206154622739](/home/wxt/.config/Typora/typora-user-images/image-20231206154622739.png)

<center>图2.3 增添DMA扩展SoC设计

### 2.3 外设访问接口

​	图2.5为将AHB接口转为SRAM接口示意图。处理器DBUS总线接口根据不同的地址区间访问不同的外设：ITCM、DTCM、UART、TIMER等，转化为相应的SRAM接口进行读写操作。

![img](file:////tmp/wps-wxt/ksohtml/wps7rJY08.jpg) 

<center>图2.5 AHB转SRAM接口</center>

​	图2.6表示UART串口、TIMER计时器相关配置寄存器在软件中定义的地址。通过地址0x4000004配置UART串口传送的数据类型，通过地址0x4000008配置UART串口波特率，通过地址0x4000010发送串口数据，在实现PC端串口窗口打印功能。

​	使用TIMER计时器，通过地址0x4000040配置计时时长，通过地址0x4000044开启计时功能，计时结束后触发计时中断。    

![image-20231206154951457](/home/wxt/.config/Typora/typora-user-images/image-20231206154951457.png)

<center>图2.6 UART、TIMER地址定义

## 3 仿真结果

### **3.1 仿真验证环境**

​	为了验证处理器的功能并测试性能，本文设计的验证流程如图3.1所示：

![image-20231206155217696](/home/wxt/.config/Typora/typora-user-images/image-20231206155217696.png)



<center>图3.1 验证流程
    
</center>

​	搭建Linux系统下RISC-V gcc编译环境，用于生成RISC-V架构机器测试代码。然后用C语言编写测试代码，通过gcc编译生成可执行机器代码。将处理器设计工程代码以及tb测试文件通过 Modelsim进行编译，tb测试文件将上一步生成的测试机器代码读入指令存储器中，运行仿真，查看波形图，并将波形图中结果数据与C代码执行预期结果进行比较，如果相同，表明该测试代码通过。

### 3.2 处理器验证

#### 3.2.1 指令集验证

​	RISC-V基金会开源了一个用于测试RISC-V架构处理器的项目riscv-tests。riscv-tests是一种指令集自测试集，能够自我检测指令集运行成功还是失败的测试程序。每条指令均有相应的测试程序，这些程序基本由汇编语言编写，覆盖了为测试该指令可能的若干种输入操作数情形。图3.2为测试add指令的汇编代码，其中包括了37种测试情形。例如第一种情形测试0与0相加，标准结果为0，如果处理器在执行该测试代码第一种情形时，实际执行相加得到的结果与标准结果不一致，则会跳转到fail段代码，即表明该指令测试没有通过，处理器设计逻辑有误。如果第一种测试情形得到的和为0，与标准结果一致，则顺序执行下面的测试用例。第二种情形为计算1与1相加，第三种情形为3与7相加，一直到最后第37种情形验证均通过，执行pass段代码，将x3寄存器赋值为1，最终可以通过x3寄存器的值来判断指令所有测试情形是否通过。图3.3为可执行文件的部分反汇编代码。

![image-20231206155338467](/home/wxt/.config/Typora/typora-user-images/image-20231206155338467.png)

<center>图3.2 add指令汇编代码

![image-20231206155400053](/home/wxt/.config/Typora/typora-user-images/image-20231206155400053.png)

<center>图3.3 add指令反汇编代码

​	其modelsim波形仿真图如图3.4所示，自研处理器在执行该指令测试代码时，最终执行到pass段代码，将1写回x3寄存器。

![image-20231206155444140](/home/wxt/.config/Typora/typora-user-images/image-20231206155444140.png)

<center>图3.4 add指令波形仿真
    
</center>

​	基于自研RISC-V处理器执行所有其他指令的测试用例，检测x3寄存器中的值，所有指令均测试通过

#### 3.2.2 应用程序验证

​	载入操作系统应用程序，进行modelsim波形仿真，如图3.5所示。经验证，执行无误，能够正确跑通整个操作系统应用程序。

![image-20231206155547936](/home/wxt/.config/Typora/typora-user-images/image-20231206155547936.png)

<center>图3.5 应用程序波形仿真
## 4 FPGA

### **4.1 FPGA综合结果**

​	将该工程在FPGA：xc7z020clg400-2上综合实现，RISC-V处理器在50MHz时钟约束下占用资源如下表4.1所示：

<center>表4.1 RISC-V处理器资源消耗
    
</center>

| Resource | Utilization | Available | Utilization % |
| -------- | ----------- | --------- | ------------- |
| LUT      | 2425        | 53200     | 4.56          |
| FF       | 1363        | 106400    | 1.28          |
| IO       | 76          | 125       | 60.80         |
| BUFG     | 1           | 32        | 3.13          |

​	其时序裕量如下图4.1所示，故其最大时钟频率为62MHz。

![image-20231206155841477](/home/wxt/.config/Typora/typora-user-images/image-20231206155841477.png)

<center>图4.1 RISC-V处理器implementation时序
    
</center>

整体SoC在50MHz时序约束下资源消耗如下：

<center>表4.2 SoC资源消耗
    
</center>

SourceURL:file:///media/wxt/Ventoy/实验报告wangzhe.docx

| Resource | Utilization | Available | Utilization % |
| -------- | ----------- | --------- | ------------- |
| LUT      | 4419        | 53200     | 8.31          |
| FF       | 2303        | 106400    | 2.16          |
| BRAM     | 33          | 140       | 23.57         |
| DSP      | 4           | 220       | 1.82          |
| IO       | 7           | 125       | 5.60          |
| BUFG     | 1           | 32        | 3.13          |

功耗如图4.2所示：

![image-20231206160002896](/home/wxt/.config/Typora/typora-user-images/image-20231206160002896.png)

### 4.2 FPGA调试结果

FPGA整体实物如图4.3所示。	与PC连接有两根数据线。一根通过jtag口连接PC用来下载bit流文件，一根通过TTL接口连接PC USB接口，用来进行串口通信。

![image-20231206160513096](/home/wxt/.config/Typora/typora-user-images/image-20231206160513096.png)

<center>图4.3 FPGA实物图

串口打印结果如图4.4所示。

![image-20231206160616006](/home/wxt/.config/Typora/typora-user-images/image-20231206160616006.png)

<center>图4.4 串口打印结果</center>

## 5 **实验收获**

​	经过几个月的学习和实践，我们小组成功使用Verilog设计了一个RISC-V架构的处理器、编写了基于RISC-V指令的简易操作系统、以及设计了XXX编译器。本次实验我们按照成员爱好分成了三个组，尽可能地发挥大家所擅长的内容。在CPU设计过程中我们学到了以下几点：1.了解了RISC-V架构：在设计RISC-V处理器之前，我们首先了解了RISC-V架构。RISC-V是一种新兴的指令集架构，具有精简、可扩展、开放等特点，越来越受到业界的关注。在设计RISC-V处理器之前，我们需要了解RISC-V指令集的格式、功能以及处理器架构等相关知识。2.熟悉了Verilog语言：Verilog是一种硬件描述语言，用于数字电路的系统设计，Verilog 继承了 C 语言的多种操作符和结构，与另一种硬件描述语言 VHDL 相比，语法不是很严格，代码更加简洁，更容易上手。在本次实验中，我们使用Verilog编写了RISC-V处理器的设计，并通过仿真和测试验证了其正确性。通过实践，我们对Verilog语言的使用有了更深入的理解和掌握。3.掌握了处理器设计的基本原理：在设计处理器时，我们需要考虑指令的执行流程、寄存器的读写、数据通路的设计等内容。通过本次实验，我们了解了处理器设计的基本原理和流程，并掌握了一些设计技巧。4.学习了调试和优化技巧：在设计处理器时，可能会出现一些错误或性能问题，需要进行调试和优化。通过本次实验，我们学会了使用仿真工具进行调试，并尝试了一些优化技巧，如流水线、缓存等。

​	总的来说，本次实验是一次非常具有挑战性和难度的实验，通过这次实验，我们小组的每一个人都对上个学期所学的计算机体系结构课程内容有了一个很直观的实践，这次实验不仅锻炼了我们的实际动手能力，还锻炼了我们的团队协作能力，对以后的科研以及工作都能起到非常大的帮助。

# 附录

## 成员分工

编译器设计：

徐文浚：负责编译器中端后端

许涛涛：负责编译器前端

操作系统设计：

王哲：负责实现Board层、kernel底层以及系统测试工作

硬件设计:

魏肖彤：负责硬件部分实现

徐浩然：FPGA上板调试，串口打印

徐文浚：负责硬件部分实现